import os, subprocess, threading, signal
from http import server
from urllib.parse import urlparse, parse_qs
from subprocess import check_call, call
from time import sleep
from os import system, path
import json

import letslapse.browser as browser
import letslapse.utils as utils
import letslapse.db as db


siteRoot = "/home/steven/letslapse"
letslapse_streamerPath = siteRoot+"/letslapse/streamer.py"    #CHANGE PATH TO LOCATION OF streamer.py

def letslapse_streamer_thread():
    call(["python3", letslapse_streamerPath])


def checkStreamerIsRunning():
    instanceCount = 0
    for line in os.popen("ps -f -C python3 | grep streamer.py"):
        print(line)
        instanceCount = instanceCount + 1
        if instanceCount > 0:
            return True
        else: 
            return False

def check_kill_process(pstring):
    for line in os.popen("ps ax | grep " + pstring + " | grep -v grep"):
        fields = line.split()
        pid = fields[0]
        os.kill(int(pid), signal.SIGKILL)


class MyHttpRequestHandler(server.BaseHTTPRequestHandler):
    def do_GET(self):
        print(urlparse(self.path))
        query_components = parse_qs(urlparse(self.path).query)
        if 'action' in query_components:
            # Sending an '200 OK' response
            self.send_response(200)
            # Setting the header
            self.send_header("Content-type", "application/json")
            actionVal = query_components["action"][0]

            # Some custom HTML code, possibly generated by another function
            jsonResp = '{'
            jsonResp += '"completedAction":"'+actionVal+'"'
            
            if actionVal == "timelapse" :
                check_kill_process("streamer.py")
                #check to see if this timelapse project is already in place - don't make a new one, if so
                shootName = query_components["shootName"][0]

                if "includeRaw" in query_components:
                    includeRaw = query_components["includeRaw"][0]
                    if includeRaw == "false":
                        includeRaw = False
                else:
                    includeRaw = False
                
                if "underexposeNights" in query_components:
                    underexposeNights = query_components["underexposeNights"][0]
                else:
                    underexposeNights = False
                
                if "lockExposure" in query_components:
                    lockExposure = query_components["lockExposure"][0]
                else:
                    lockExposure = False
                
                if "shutterSpeed" in query_components:
                    shutterSpeed = query_components["shutterSpeed"][0]
                else:
                    shutterSpeed = 8000
                
                if "analogueGains" in query_components:
                    analogueGains = query_components["analogueGains"][0]
                else:
                    analogueGains = 1
                
                if "digitalGains" in query_components:
                    digitalGains = query_components["digitalGains"][0]
                else:
                    digitalGains = 1

                if "delayBetweenShots" in query_components:
                    delayBetweenShots = query_components["delayBetweenShots"][0]
                else:
                    delayBetweenShots = 0

                if "exitAfter" in query_components:
                    exitAfter = query_components["exitAfter"][0]
                else:
                    exitAfter = 0
                
                
                if "ultraBasic" in query_components:
                    ultraBasic = query_components["ultraBasic"][0]
                    if ultraBasic == "false":
                        ultraBasic = False
                else:
                    ultraBasic = False
                
                if "disableAWBG" in query_components:
                    disableAWBG = query_components["disableAWBG"][0]
                else:
                    disableAWBG = False
                
                if "width" in query_components:
                    width = query_components["width"][0]
                else:
                    width = 4096
                
                if "startingGains" in query_components:
                    startingGains = query_components["startingGains"][0]
                else:
                    startingGains = False
                
                if "useThumbnail" in query_components:
                    useThumbnail = query_components["useThumbnail"][0]
                else:
                    useThumbnail = False
                
                
                jsonResp += ',"shootName":"'+shootName+'"'
                if path.isfile("progress.txt") == True:
                    #in an early version, this file was created as a flat txt file, but since migrated as a sqlite file - as such, a request for this will just get the JSON and fake the text file
                    jsonResp += ',"error":false'
                    
                    jsonResp += ',"message":"resuming"'
                    #must be continuing the shoot
                    startTimelapse(shootName, includeRaw, underexposeNights, ultraBasic, disableAWBG, width, startingGains, useThumbnail)

                elif path.isdir("timelapse_"+shootName) == True :
                    print("project with the same name already in use")
                    jsonResp += ',"error":true'
                    jsonResp += ',"message":"used"'
                else: 
                    #this instance is a new shoot
                    jsonResp += ',"error":false'
                    jsonResp += ',"message":"starting"'
                    startTimelapse(shootName, includeRaw, underexposeNights, ultraBasic, disableAWBG, width, startingGains, useThumbnail, lockExposure, shutterSpeed, analogueGains, digitalGains, delayBetweenShots, exitAfter)
                sleep(3) #gives time for the timelapse to start
                
            elif actionVal == "preview" :
                jsonResp += ',"filename":"'+utils.shootPreview(query_components)+'"'
            elif actionVal == "killtimelapse" :
                #?action=killtimelapse&pauseOrKill=kill
                check_kill_process("ll_timelapse.py")
                check_kill_process("raspistill")
                if query_components["pauseOrKill"][0] == "kill":
                    #update DB where the endTime value gets set
                    #system("rm progress.txt")
                    utils.killTimelapseDB()
            elif actionVal == "killstreamer" :
                check_kill_process("streamer.py")
            elif actionVal == "startstreamer" :
                processThread = threading.Thread(target=letslapse_streamer_thread)
                processThread.start()
                sleep(4) #ideally this would wait for a callback, but this allows the camera to start
                isStreamerRunning = checkStreamerIsRunning()
                print("isStreamerRunning - TEST 1")
                print(isStreamerRunning)
                checkStreamerIsRunningCount = 0
                
                while isStreamerRunning == False :
                    sleep(4)
                    isStreamerRunning = checkStreamerIsRunning()
                    checkStreamerIsRunningCount = checkStreamerIsRunningCount+1
                    print(isStreamerRunning)
                    print("checkStreamerIsRunningCount" + str(checkStreamerIsRunningCount))
                
            elif actionVal == "getAWBG" :
                measuredGains = utils.detectAWBG()
                jsonResp += ',"awbg":"'+ str(float(measuredGains[0])) +','+str(float(measuredGains[1]))+'"'
            elif actionVal == "uptime" :
                uptime = subprocess.check_output("echo $(awk '{print $1}' /proc/uptime)", shell=True)
                hostname = os.uname()[1]
                print(float(uptime))
                jsonResp += ',"seconds":"'+str(float(uptime))+'"'
                jsonResp += ',"hostname":"'+str(hostname)+'"'
            elif actionVal == "updatecode" :
                myhost = os.uname()[1]
                jsonResp += ',"hostname":"'+myhost+'"'
                updatecode = "git --git-dir=/home/pi/letslapse/.git pull"
                if(myhost == "gs66"):
                    updatecode = "git --git-dir="+siteRoot+"/.git pull"
                updateCodeResp = subprocess.check_output(updatecode, shell=True).strip()
                #updateCodeResp.split()
                jsonResp += ',"updateCodeResp":'+str(json.dumps(updateCodeResp.decode('utf-8')))
                #print(updatecode)
            elif actionVal == "blend" :
                jsonResp += ',"processing":"'+str(query_components["shootName"][0])+'"'
                jsonResp += ',"speed":"'+str(query_components["processingSpeed"][0])+'"'
                
                strToFire = "nohup ./blend.sh "+ str(query_components["processingSpeed"][0]) + " " + str(query_components["shootName"][0]) + " &"
                print(strToFire)
                system(strToFire)

            elif actionVal == "listshoots":
                #for display of projects and still shots
                print("tbc")
                folderLen = (len(next(os.walk('.'))[1]))
            
            elif actionVal == "getStills":
                
                jsonResp += ',"stills":'+str( json.dumps( browser.getStills() ) )
                #print(browser.getShoots("0.jpg"))
            
            elif actionVal == "getVideos":
                
                jsonResp += ',"videos":'+str( json.dumps( browser.getVideos() ) )
                #print(browser.getShoots("0.jpg"))
            
            
            elif actionVal == "getShoots":
                
                jsonResp += ',"gallery":'+str( json.dumps( browser.getShoots("00.jpg") ) )
                #print(browser.getShoots("0.jpg"))


            elif actionVal == "quit" :
                exit()

            jsonResp += '}'
            print(actionVal)
             # Whenever using 'send_header', you also have to call 'end_headers'
            self.end_headers()
            # Writing the HTML contents with UTF-8
            self.wfile.write(bytes(jsonResp, "utf8"))

            if actionVal == "exit" :
                check_kill_process("ll_timelapse.py")
                check_kill_process("streamer.py")
                exit()
            if actionVal == "shutdown" :
                check_kill_process("ll_timelapse.py")
                check_kill_process("streamer.py")
                system("sudo shutdown now")
            elif actionVal == "reset" :
                check_kill_process("ll_timelapse.py")
                check_kill_process("streamer.py")
                system("sudo reboot now")
            
            return
        elif self.path == '/':
            self.send_response(301)
            self.send_header('Location', '/index.html')
            self.end_headers()
        
        else :

            #if an image is requested that doesn't exist, it's probably a thumbnail request - in this event, extract it from the image and save it
            if self.path.endswith('_thumb.jpg'):
                if path.isfile(siteRoot+self.path) == False:
                    print("Extract the thum - it's not available. Temp function, should kill this")
                    exifCommand = "exiftool -b -ThumbnailImage "+siteRoot+self.path.replace("_thumb", "")+" > "+siteRoot+self.path
                    
                    exifProcess = subprocess.check_output(exifCommand, shell=True)
                
            if self.path == "/progress.txt":
                #progress.txt was formally a static file, but now is dynamically generated
                jsonResp = db.createProgressTxtFromDB()
                
                self.send_response(200)
                self.send_header("Content-type", "application/json")
                
                self.end_headers()
                self.wfile.write(bytes(jsonResp, "utf8"))
                    #with open(siteRoot+self.path, 'rb') as file: 
                    #    self.wfile.write(file.read())

            else:
                print("General FILE serving")
                self.send_response(200)
                if self.path.endswith('.svg'):
                    self.send_header('Content-Type', 'image/svg+xml')
                elif self.path.endswith('.css'):
                    self.send_header('Content-Type', 'text/css')
                elif self.path.endswith('.js'):
                    self.send_header('Content-Type', 'application/javascript')
                elif self.path.endswith('.jpg'):
                    self.send_header('Content-Type', 'image/jpeg')
                elif self.path.endswith('.mp4'):
                    self.send_header('Content-Disposition', 'attachment; filename="'+os.path.basename(self.path)+'"')
                    self.send_header('Content-Type', 'video/mp4')
#                    self.send_header('Content-Length', len(self.path))
                else:
                    self.send_header('Content-Type', 'text/html')

                
                self.end_headers()
                
                with open(siteRoot+self.path, 'rb') as file: 
                    self.wfile.write(file.read())
            
                
            #self.send_response(200)
            #self.send_header('Content-Type', 'text/html')
            #return http.server.SimpleHTTPRequestHandler.do_GET(self)

        #

